# 202530222 안형주

---

### 1️⃣ Hello World (`print_hello.c`)

```bash
$ ./print_hello
Hello, World!
```

* C언어 기본 입출력 예제.
* `printf()` 함수 이해.

---

### 2️⃣ 두 수의 합 (`sum_two_numbers.c`)

```bash
$ ./sum_two_numbers
두 수를 입력하세요: 10 20
합: 30
```

* `scanf()`로 입력받아 합 출력.

---

### 3️⃣ 평균 구하기 (`average_input.c`)

* 최대 10개의 정수를 입력받아 평균 계산.
* `#define SIZE 10`으로 배열 크기 고정.

---

### 4️⃣ 최대값 찾기 (`find_max.c`)

* 고정 배열 내에서 가장 큰 값을 탐색.
* 반복문과 조건문의 기초.

---

### 5️⃣ 짝수 개수 세기 (`count_even.c`)

* 배열을 순회하며 짝수의 개수를 카운트.
* 조건문과 카운터 변수 연습.

---

### 6️⃣ 배열 복사 (`copy_array.c`)

* 한 배열의 모든 요소를 다른 배열로 복사.
* 인덱스 접근 및 for문 반복 구조 복습.

---

### 7️⃣ 역순 출력 (`reverse_array.c`)

* 배열을 뒤에서부터 출력.
* `for (i = SIZE - 1; i >= 0; i--)` 구문 사용.

---

### 8️⃣ 선형 탐색 (`linear_search.c`)

* 입력한 값이 배열에 있는지 순차 탐색.
* 일치 시 인덱스 출력, 없으면 메시지 출력.

---

### 9️⃣ 최소값 찾기 (`min_index.c`)

* 배열에서 최소값과 해당 인덱스를 출력.
* 비교문(`if`)을 통한 탐색 패턴 이해.

---

### 🧩 버블 정렬 (Bubble Sort)

**인접한 두 원소를 비교하며 큰 값을 뒤로 보내는 정렬 알고리즘**입니다.
가장 단순한 방식으로 구현은 쉽지만 효율은 낮습니다.

* **시간 복잡도:** O(n²)
* **공간 복잡도:** O(1)
* **특징:** 구현 간단, 안정 정렬(Stable Sort)

#### 🔹 동작 예시

초기 배열: `[5, 3, 8, 4, 2]`
1️⃣ `[3, 5, 4, 2, 8]`
2️⃣ `[3, 4, 2, 5, 8]`
3️⃣ `[2, 3, 4, 5, 8]`
✅ 최종 정렬 완료

#### 🔹 실행 예시

```bash
$ ./bubble_sort
정렬 전: 5 3 8 4 2
정렬 후: 2 3 4 5 8
```

#### 🔹 주요 함수

* `bubbleSort(int a[], int n)` : 버블 정렬 수행
* `swap(int *x, int *y)` : 두 값 교환
* `printArray(int a[], int n)` : 배열 출력

---

### 🧩 선택 정렬 (Selection Sort)

배열에서 **가장 작은 값을 선택해 앞으로 보내는 방식의 정렬 알고리즘**입니다.
단순하지만 정렬의 기본 개념을 익히기에 적합합니다.

* **시간 복잡도:** O(n²)
* **공간 복잡도:** O(1)
* **특징:** 단순하지만 비효율적, 불안정 정렬(Unstable Sort)

#### 🔹 동작 예시

초기 배열: `[64, 25, 12, 22, 11]`
1️⃣ 최소값 11 → `[11, 25, 12, 22, 64]`
2️⃣ 최소값 12 → `[11, 12, 25, 22, 64]`
3️⃣ 최소값 22 → `[11, 12, 22, 25, 64]`
✅ 최종 정렬 완료

#### 🔹 실행 예시

```bash
$ ./selection_sort
정렬 전: 64 25 12 22 11
정렬 후: 11 12 22 25 64
```

#### 🔹 주요 함수

* `selectionSort(int a[], int n)` : 선택 정렬 수행
* `swap(int *x, int *y)` : 두 값 교환
* `printArray(int a[], int n)` : 배열 출력

---

### 🧩 삽입 정렬 (Insertion Sort)

**이미 정렬된 부분 배열에 새 원소를 적절한 위치에 삽입**하며 정렬하는 알고리즘입니다.
작은 데이터나 거의 정렬된 배열에 효율적입니다.

* **시간 복잡도:** O(n²)
* **공간 복잡도:** O(1)
* **특징:** 안정 정렬(Stable Sort), 구현 간단

#### 🔹 동작 예시

초기 배열: `[5, 2, 4, 6, 1]`
1️⃣ `[2, 5, 4, 6, 1]`
2️⃣ `[2, 4, 5, 6, 1]`
3️⃣ `[1, 2, 4, 5, 6]`
✅ 최종 정렬 완료

#### 🔹 실행 예시

```bash
$ ./insertion_sort
정렬 전: 5 2 4 6 1
정렬 후: 1 2 4 5 6
```

#### 🔹 주요 함수

* `insertionSort(int a[], int n)` : 삽입 정렬 수행
* `printArray(int a[], int n)` : 배열 출력

---

### 🧩 셸 정렬 (Shell Sort)

**삽입 정렬을 개선한 알고리즘**으로, 일정한 간격(gap)으로 떨어진 원소들을 먼저 정렬한 뒤
간격을 줄여가며 전체를 정렬합니다.

* **시간 복잡도:** 평균 O(n¹·⁵) ~ O(n²)
* **공간 복잡도:** O(1)
* **특징:** 삽입 정렬보다 빠름, 불안정 정렬(Unstable Sort)

#### 🔹 동작 예시

초기 배열: `[8, 5, 2, 6, 9, 3]`
1️⃣ gap=3 → `[8, 5, 2, 6, 9, 3]` → `[6, 3, 2, 5, 8, 9]`
2️⃣ gap=1 → 삽입 정렬 수행 → `[2, 3, 5, 6, 8, 9]`
✅ 최종 정렬 완료

#### 🔹 실행 예시

```bash
$ ./shell_sort
정렬 전: 8 5 2 6 9 3
정렬 후: 2 3 5 6 8 9
```

#### 🔹 주요 함수

* `shellSort(int a[], int n)` : 셸 정렬 수행
* `printArray(int a[], int n)` : 배열 출력

---

### 🧩 퀵 정렬 (Quick Sort)

**분할 정복(Divide and Conquer)** 원리를 이용한 빠른 정렬 알고리즘입니다.
기준값(pivot)을 중심으로 작은 값과 큰 값을 나누어 재귀적으로 정렬합니다.

* **시간 복잡도:** 평균 O(n log n), 최악 O(n²)
* **공간 복잡도:** O(log n)
* **특징:** 매우 빠름, 불안정 정렬(Unstable Sort)

#### 🔹 동작 예시

초기 배열: `[5, 8, 4, 2, 7, 1, 3]`
1️⃣ pivot=5 → `[4,2,1,3] | 5 | [8,7]`
2️⃣ 왼쪽(4,2,1,3) → pivot=2 → `[1] | 2 | [3,4]`
3️⃣ 오른쪽(8,7) → `[7] | 8`
✅ 최종 결과: `[1, 2, 3, 4, 5, 7, 8]`

#### 🔹 실행 예시

```bash
$ ./quick_sort
정렬 전: 5 8 4 2 7 1 3
정렬 후: 1 2 3 4 5 7 8
```

#### 🔹 주요 함수

* `quickSort(int a[], int left, int right)` : 퀵 정렬 수행
* `partition(int a[], int left, int right)` : 피벗 기준 분할
* `printArray(int a[], int n)` : 배열 출력
y









gcc -o test test.c
./test

