# 202530222 안형주

---

### 1️⃣ Hello World (`print_hello.c`)

```bash
$ ./print_hello
Hello, World!
```

* C언어 기본 입출력 예제.
* `printf()` 함수 이해.

---

### 2️⃣ 두 수의 합 (`sum_two_numbers.c`)

```bash
$ ./sum_two_numbers
두 수를 입력하세요: 10 20
합: 30
```

* `scanf()`로 입력받아 합 출력.

---

### 3️⃣ 평균 구하기 (`average_input.c`)

* 최대 10개의 정수를 입력받아 평균 계산.
* `#define SIZE 10`으로 배열 크기 고정.

---

### 4️⃣ 최대값 찾기 (`find_max.c`)

* 고정 배열 내에서 가장 큰 값을 탐색.
* 반복문과 조건문의 기초.

---

### 5️⃣ 짝수 개수 세기 (`count_even.c`)

* 배열을 순회하며 짝수의 개수를 카운트.
* 조건문과 카운터 변수 연습.

---

### 6️⃣ 배열 복사 (`copy_array.c`)

* 한 배열의 모든 요소를 다른 배열로 복사.
* 인덱스 접근 및 for문 반복 구조 복습.

---

### 7️⃣ 역순 출력 (`reverse_array.c`)

* 배열을 뒤에서부터 출력.
* `for (i = SIZE - 1; i >= 0; i--)` 구문 사용.

---

### 8️⃣ 선형 탐색 (`linear_search.c`)

* 입력한 값이 배열에 있는지 순차 탐색.
* 일치 시 인덱스 출력, 없으면 메시지 출력.

---

### 9️⃣ 최소값 찾기 (`min_index.c`)

* 배열에서 최소값과 해당 인덱스를 출력.
* 비교문(`if`)을 통한 탐색 패턴 이해.

---

### 🧩 버블 정렬 (Bubble Sort)

**인접한 두 원소를 비교하며 큰 값을 뒤로 보내는 정렬 알고리즘**입니다.
가장 단순한 방식으로 구현은 쉽지만 효율은 낮습니다.

* **시간 복잡도:** O(n²)
* **공간 복잡도:** O(1)
* **특징:** 구현 간단, 안정 정렬(Stable Sort)

#### 🔹 동작 예시

초기 배열: `[5, 3, 8, 4, 2]`
1️⃣ `[3, 5, 4, 2, 8]`
2️⃣ `[3, 4, 2, 5, 8]`
3️⃣ `[2, 3, 4, 5, 8]`
✅ 최종 정렬 완료

#### 🔹 실행 예시

```bash
$ ./bubble_sort
정렬 전: 5 3 8 4 2
정렬 후: 2 3 4 5 8
```

#### 🔹 주요 함수

* `bubbleSort(int a[], int n)` : 버블 정렬 수행
* `swap(int *x, int *y)` : 두 값 교환
* `printArray(int a[], int n)` : 배열 출력

---

### 🧩 선택 정렬 (Selection Sort)

배열에서 **가장 작은 값을 선택해 앞으로 보내는 방식의 정렬 알고리즘**입니다.
단순하지만 정렬의 기본 개념을 익히기에 적합합니다.

* **시간 복잡도:** O(n²)
* **공간 복잡도:** O(1)
* **특징:** 단순하지만 비효율적, 불안정 정렬(Unstable Sort)

#### 🔹 동작 예시

초기 배열: `[64, 25, 12, 22, 11]`
1️⃣ 최소값 11 → `[11, 25, 12, 22, 64]`
2️⃣ 최소값 12 → `[11, 12, 25, 22, 64]`
3️⃣ 최소값 22 → `[11, 12, 22, 25, 64]`
✅ 최종 정렬 완료

#### 🔹 실행 예시

```bash
$ ./selection_sort
정렬 전: 64 25 12 22 11
정렬 후: 11 12 22 25 64
```

#### 🔹 주요 함수

* `selectionSort(int a[], int n)` : 선택 정렬 수행
* `swap(int *x, int *y)` : 두 값 교환
* `printArray(int a[], int n)` : 배열 출력

---

### 🧩 삽입 정렬 (Insertion Sort)

**이미 정렬된 부분 배열에 새 원소를 적절한 위치에 삽입**하며 정렬하는 알고리즘입니다.
작은 데이터나 거의 정렬된 배열에 효율적입니다.

* **시간 복잡도:** O(n²)
* **공간 복잡도:** O(1)
* **특징:** 안정 정렬(Stable Sort), 구현 간단

#### 🔹 동작 예시

초기 배열: `[5, 2, 4, 6, 1]`
1️⃣ `[2, 5, 4, 6, 1]`
2️⃣ `[2, 4, 5, 6, 1]`
3️⃣ `[1, 2, 4, 5, 6]`
✅ 최종 정렬 완료

#### 🔹 실행 예시

```bash
$ ./insertion_sort
정렬 전: 5 2 4 6 1
정렬 후: 1 2 4 5 6
```

#### 🔹 주요 함수

* `insertionSort(int a[], int n)` : 삽입 정렬 수행
* `printArray(int a[], int n)` : 배열 출력

---

### 🧩 셸 정렬 (Shell Sort)

**삽입 정렬을 개선한 알고리즘**으로, 일정한 간격(gap)으로 떨어진 원소들을 먼저 정렬한 뒤
간격을 줄여가며 전체를 정렬합니다.

* **시간 복잡도:** 평균 O(n¹·⁵) ~ O(n²)
* **공간 복잡도:** O(1)
* **특징:** 삽입 정렬보다 빠름, 불안정 정렬(Unstable Sort)

#### 🔹 동작 예시

초기 배열: `[8, 5, 2, 6, 9, 3]`
1️⃣ gap=3 → `[8, 5, 2, 6, 9, 3]` → `[6, 3, 2, 5, 8, 9]`
2️⃣ gap=1 → 삽입 정렬 수행 → `[2, 3, 5, 6, 8, 9]`
✅ 최종 정렬 완료

#### 🔹 실행 예시

```bash
$ ./shell_sort
정렬 전: 8 5 2 6 9 3
정렬 후: 2 3 5 6 8 9
```

#### 🔹 주요 함수

* `shellSort(int a[], int n)` : 셸 정렬 수행
* `printArray(int a[], int n)` : 배열 출력

---

### 🧩 퀵 정렬 (Quick Sort)

**분할 정복(Divide and Conquer)** 원리를 이용한 빠른 정렬 알고리즘입니다.
기준값(pivot)을 중심으로 작은 값과 큰 값을 나누어 재귀적으로 정렬합니다.

* **시간 복잡도:** 평균 O(n log n), 최악 O(n²)
* **공간 복잡도:** O(log n)
* **특징:** 매우 빠름, 불안정 정렬(Unstable Sort)

#### 🔹 동작 예시

초기 배열: `[5, 8, 4, 2, 7, 1, 3]`
1️⃣ pivot=5 → `[4,2,1,3] | 5 | [8,7]`
2️⃣ 왼쪽(4,2,1,3) → pivot=2 → `[1] | 2 | [3,4]`
3️⃣ 오른쪽(8,7) → `[7] | 8`
✅ 최종 결과: `[1, 2, 3, 4, 5, 7, 8]`

#### 🔹 실행 예시

```bash
$ ./quick_sort
정렬 전: 5 8 4 2 7 1 3
정렬 후: 1 2 3 4 5 7 8
```

#### 🔹 주요 함수

* `quickSort(int a[], int left, int right)` : 퀵 정렬 수행
* `partition(int a[], int left, int right)` : 피벗 기준 분할
* `printArray(int a[], int n)` : 배열 출력


### 🧩 병합 정렬 (Merge Sort)

**분할 정복(Divide and Conquer)** 원리를 이용한 정렬 알고리즘입니다.  
배열을 반으로 나누어 각각 정렬한 뒤 병합(merge)하는 방식으로 동작합니다.

- **시간 복잡도:** O(n log n)  
- **공간 복잡도:** O(n)  
- **특징:** 안정 정렬(Stable Sort), 일정한 수행 시간, 재귀적 구조

#### 🔹 동작 예시
초기 배열: `[38, 27, 43, 3, 9, 82, 10]`  
1️⃣ 반으로 나눔 → `[38, 27, 43, 3]` | `[9, 82, 10]`  
2️⃣ 각각 정렬 → `[3, 27, 38, 43]` | `[9, 10, 82]`  
3️⃣ 병합 → `[3, 9, 10, 27, 38, 43, 82]`  
✅ 최종 정렬 완료

#### 🔹 실행 예시
```bash
$ ./merge_sort
정렬 전: 38 27 43 3 9 82 10
정렬 후: 3 9 10 27 38 43 82
```

#### 🔹 주요 함수
- `mergeSort(int a[], int left, int right)` : 병합 정렬 수행  
- `merge(int a[], int left, int mid, int right)` : 두 부분 배열 병합  
- `printArray(int a[], int n)` : 배열 출력

---

### 🧩 힙 정렬 (Heap Sort)

**완전 이진 트리(Heap)** 구조를 이용한 정렬 알고리즘입니다.  
최대 힙(Max Heap)을 구성해 루트(가장 큰 값)를 하나씩 꺼내 배열 뒤에 배치하는 방식으로 동작합니다.

- **시간 복잡도:** O(n log n)  
- **공간 복잡도:** O(1)  
- **특징:** 불안정 정렬(Unstable Sort), 일정한 성능, 재귀 없이도 구현 가능

#### 🔹 동작 예시
초기 배열: `[4, 10, 3, 5, 1]`  
1️⃣ 최대 힙 구성 → `[10, 5, 3, 4, 1]`  
2️⃣ 루트(10) 제거 후 재정렬 → `[5, 4, 3, 1, 10]`  
3️⃣ 루트(5) 제거 후 재정렬 → `[4, 1, 3, 5, 10]`  
✅ 최종 정렬 완료: `[1, 3, 4, 5, 10]`

#### 🔹 실행 예시
```bash
$ ./heap_sort
정렬 전: 4 10 3 5 1
정렬 후: 1 3 4 5 10
```

#### 🔹 주요 함수
- `heapSort(int a[], int n)` : 힙 정렬 수행  
- `heapify(int a[], int n, int i)` : 힙 특성 유지  
- `printArray(int a[], int n)` : 배열 출력


---

### 🧩 도수 정렬 (Counting Sort)

**값의 개수를 세어 정렬하는 알고리즘**으로, 비교 연산 없이 정렬이 가능합니다.  
주어진 값들이 **정수이면서 범위가 한정적일 때 매우 효율적**입니다.

- **시간 복잡도:** O(n + k) (n: 데이터 개수, k: 최댓값)  
- **공간 복잡도:** O(k)  
- **특징:** 매우 빠름, 안정 정렬(Stable Sort), 정수형 데이터에만 적용 가능  

#### 🔹 동작 예시
초기 배열: `[4, 2, 2, 8, 3, 3, 1]`  
1️⃣ 값의 개수를 센다 → count = `[0,1,2,2,1,0,0,0,1]`  
2️⃣ 누적합 계산 → `[0,1,3,5,6,6,6,6,7]`  
3️⃣ count 기반으로 정렬된 위치에 배치 → `[1,2,2,3,3,4,8]`  
✅ 최종 정렬 완료  

#### 🔹 실행 예시
```bash
$ ./counting_sort
정렬 전: 4 2 2 8 3 3 1
정렬 후: 1 2 2 3 3 4 8

## 🌳 트리(Tree)란?

### 1️⃣ 개념
트리는 **계층적(hierarchical) 구조를 표현하는 비선형 자료구조**이다.  
노드들이 **부모-자식 관계**로 연결되며, **사이클이 존재하지 않는** 구조를 가진다.

### 2️⃣ 특징
- 하나의 시작점인 **루트(root)** 가 존재한다.
- 각 노드는 **0개 이상의 자식(child)** 을 가진다.
- **사이클이 없다.**
- 루트에서 어떤 노드든 **단 하나의 경로**로만 연결된다.
- 파일 시스템, 조직도 등 다양한 계층 구조 표현에 사용된다.

---

## 📘 트리 관련 용어

### 🔹 Node (노드)
트리를 구성하는 기본 단위.

### 🔹 Edge (간선)
노드와 노드를 연결하는 선.

### 🔹 Root (루트)
트리의 시작 노드(부모가 없음).

### 🔹 Parent / Child (부모 / 자식)
- **Parent:** 어느 노드의 상위 노드  
- **Child:** 해당 노드의 하위 노드

### 🔹 Sibling (형제 노드)
같은 부모를 가진 노드들.

### 🔹 Leaf Node (단말 노드)
자식이 없는 노드.

### 🔹 Internal Node (내부 노드)
자식 노드가 하나 이상 있는 노드.

### 🔹 Degree (차수)
- **노드의 차수:** 자식의 수  
- **트리의 차수:** 모든 노드 중 최대 차수

### 🔹 Level (레벨)
루트는 Level 1이며, 아래로 갈수록 Level이 증가한다.

### 🔹 Height / Depth (높이 / 깊이)
- **노드 깊이(depth):** 루트에서 해당 노드까지의 거리  
- **노드 높이(height):** 해당 노드에서 가장 깊은 자식까지 거리  
- **트리 높이:** 루트 노드의 높이

### 🔹 Subtree (서브트리)
특정 노드를 루트로 하는 작은 트리 구조.

### 🔹 Path (경로)
두 노드를 연결하는 노드들의 순서.

### 🔹 Binary Tree (이진 트리)
각 노드가 최대 2개의 자식만 가지는 트리.

---

## 🧩 예시
Root
├─ FolderA
│ ├─ File1
│ └─ File2
└─ FolderB
└─ File3

- Root: 루트 노드  
- FolderA, FolderB: 내부 노드  
- File1, File2, File3: 단말(리프) 노드





gcc -o test test.c
./test

